
<h2 id='1'>1. 切片的结构</h2>

```
type SliceHeader struct {
    Data uintptr  // 底层字节数组
    Len  int      // 当前长度
    Cap  int      // 容量
}
```


<h2 id='2'>2. 切片的定义方式</h2>

详见 003-slice-define.go

<h2 id='3'>3. 切片的操作</h2>

操作切片时，若使得底层容量不够时将导致重新分配，此时复杂度为 O(n),

一般尾部追加效率高于头部追加，这是因为元素要挪动，这和数组操作一致的

重新分配空间

- 尾部追加

```
a := make([]int, 2, 5)

// 无需分配额外内存，效率高
a = append(a, 3, 4, 5)

// 容量超限，重新规划内存和复制 O(n)
a = append(a, 6)
```

- 头部追加

```
a := make([]int, 2, 5)

// 无需分配额外内存，但涉及元素挪动，复杂度 O(n)
a = append([]int{3, 4, 5}, a...)

// 容量超限，重新规划内存和复制 O(n)
a = append([]int{6}, a...)
```

- 中间插入

链式append 实现中间插入, 但中间会创建临时切片

```

a := make([]int, 3, 6)

// 第一个位置插入
a = append(a[:1], append([]int{9}, a[1:]...)...)

// 第一个位置插入切片
a = append(a[:2], append([]int{10, 11}, a[2:]...)...)
```

- copy 优化中间插入

copy(dst, src), dst 的长度要≥ src， 是长度，不是容量，copy

是在已有元素上操作

```
// 切片扩展1个空间
a = append(a, 0)

// a[i:]向后移动1个位置
copy(a[i+1:], a[i:]) 

// 设置新添加的元素
a[i] = x

// 为x切片扩展足够的空间
a = append(a, x...)       

// a[i:]向后移动len(x)个位置
copy(a[i+len(x):], a[i:])

// 复制新添加的切片 
copy(a[i:], x)
```

>
> 切片高效操作的要点是要降低内存分配的次数，尽量保证append操作不会超出cap的容量，降低触发内存分配的次数和每次分配内存大小
>

```
var a []*int{ ... }
a = a[:len(a)-1]    // 被删除的最后一个元素依然被引用, 可能导致GC操作被阻碍


var a []*int{ ... }
a[len(a)-1] = nil // GC回收最后一个元素内存
a = a[:len(a)-1]  // 从切片删除最后一个元素
```

- 简化版的动态数组，长度不是类型的一部分

- 数组作为参数是传值，若要使得函数改变数组，需要传递数组的指针

- slice 作为参数，引用传递，但是一旦内部发生越界cap的操作，将导致切片引用发生变化，切片所做操作不再影响原来作为参数的切片

- 无论是切片还是数组，若是万无一失的保证函数内部的改变能起效，最好传递指针
