>
>[1. UML ](#1)
>
>[2. 场景](#2)
>
>[3. 优缺点](#3)
>


<p style="text-indent:2em">通过代理控制对源对象的访问，允许请求在提交给真正的底层对象时做一些额外

的处理，比如访问实际数据库前，代理不直接连接数据库进行初始化，而是等有操作在初始化连接，再比如查询

时，对一些结果缓存，客户端访问时不访问底层数据库，直接从代理缓存中下发结果。</p>



<h2 id='1'> 1. UML </h2>

<p style="text-indent:2em">代理类提供和底层对象一致的接口, 客户端使用代理类，代理类根据情况委派任务给底层</p>
<p style="text-indent:2em">开始时这个样子</p>

> client ---> DB

<p style="text-indent:2em">用了代理模式之后</p>

> client ---> proxy ---> DB

```
                                            +--------------+
                                            |   公共接口   |
                                            +--------------+
                                            |  interface   |
                                            +--------------+
                                            |  operation1()|                    
                                            |  operation2()|
                                            +------+-------+
                                                  /|\
                                                   |
                                 +-----------------+----------------------+
                                 \|/                                      | 
                       +---------+----------+                            \|/        
                       |      代理proxy     |                      +------+--------+
                       +--------------------+                      |   原底层对象  |          
                       |      inerface <>---+--------------------->+---------------+
                       +--------------------+                      | operation1()  |
                       | Proxy(LowLevelObj) |                      | operation2()  |
                       | operation1()       |                      +---------------+  
                       | operation2()       |              
                       +--------------------+             
```

<h2 id='2'> 2. 场景 </h2>

- 延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式

<p style="text-indent:2em">你无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候</p>

- 访问控制（保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。

<p style="text-indent:2em">代理可仅在客户端凭据满足要求时将请求传递给服务对象。</p>

- 本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形

<p style="text-indent:2em">在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</p>

- 记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录

<p style="text-indent:2em">缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时</p>

<p style="text-indent:2em">代理可对重复请求所需的相同结果进行缓存， 还可使用请求参数作为索引缓存的键值。</p>

- 智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。

<p style="text-indent:2em">代理会将所有获取了指向服务对象或其结果的客户端记录在案。 代理会时不时地遍历各个客户端， 检查它们是否仍在运行。 如果相应的客户端列表为空， 代理就会销毁该服务对象， 释放底层系统资源</p>

<p style="text-indent:2em"> 代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。</p>


<h2 id='3'> 2. 优缺点 </h2>

- 优点

    - 你可以在客户端毫无察觉的情况下控制服务对象

    - 如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理

    - 即使服务对象还未准备好或不存在， 代理也可以正常工作

    - 开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理


- 缺点

    - 代码可能会变得复杂， 因为需要新建许多类

    - 服务响应可能会延迟
